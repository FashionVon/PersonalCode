## C语言学习笔记 ##

C语言通过由：  `预处理``编译` `汇编` `链接` 四个步骤生成可执行文件
             
        .c文件->.i文件->.s文件->.o文件->可执行文件
        预处理：预处理阶段展开头文件和宏替换
        生成预处理文件命令如右：gcc -o filename.i filename.c -E
**编译安装**

编译环境
	编译环境包括多个工具，它们环环相扣，称作编译工具链。主要包括以下工具：
	
	工具	简介
	binutils	连接器、汇编器和其他用于目标文件和档案的工具
	gcc	编译器，将源代码转换为机器代码
	glibc	C库，提供标准例程(C函数)
	还有一些工具，能够调用工具链，实现自动化编译：
	
	autoconf	自动生成 Makefile 文件
	automake	自动生成 Makefile 文件
	make		按照 Makefile 文件中的规则编译程序
使用下列命令编译安装：

	./configure1 --prefix=/opt/xxx	配置软件特性，检查编译环境，生成 Makefile文件	最常用配置选项:指定软件的安装路径
	make	根据 Makefile 编译源代码
	sudo make install 	将编译完成的程序安装到系统中。通常需要 root权限
	make clean 	清除源代码目录中的编译结果

gcc 通过后缀来区分输入文件的类型：

	后缀	类型
	.c	C语言源代码文件
	.a	由目标文件构成的档案库文件
	.C|.cc|.cxx	C++源代码文件
	.h	程序所包含的头文件
	.i	预处理过的C源代码文件
	.ii	预处理过的C++源代码文件
	.m	Objective-C源代码文件
	.o	编译后的目标文件
	.s	汇编语言源代码文件
	.S	预编译的汇编语言源代码文件

gcc命令还有许多选项：

	-c	只编译，不链接成为可执行文件
	-o 文件名	设定输出文件名。默认为a.out
	-g	加入调试符号(默认)。1
	-O	编译、链接时进行优化，耗时比较多，但产生的可执行文件执行效率更高
	-O2	更高的优化级别，耗时更多

使用 make

	用 configure所产生的Makefile文件有几个预先设定的目标可供使用：
	
	目标	用途
	make all	产生预设的目标，只敲入make也可以
	make clean	清除编译结果
	make distclean	除了清除编译结果，也把configure所产生的 Makefile 清除掉
	make install	将程序安装到系统中
	make dist	将程序和相关的文档打包为一个压缩文档以供发布
	make distcheck	打包并检验
**结构体类型**

	代码示例:
	struct weapon{  //定义一个结构体
        char name[20];
        int atk;
        int price;
    };
    
    //定义一个该类型的结构体变量
    struct weapon weapon1 = {"weapon1", 200,200};
    printf("%s\n", weapon1.name);
    
    //结构体数组
    struct weapon weaponArr[2] = {{"weaponElement1",100,100},{"weaponElement2",200,200}};
    printf("%s,%s\n",weaponArr[0].name, weaponArr[1].name);
    
    //结构体指针
    struct weapon *w;
    w = &weapon1;
    printf("%s; %s\n", w->name, (*w).name);
    
    struct weapon *wArr;
    wArr = weaponArr;
    printf("%s; %s\n", wArr->name, (++wArr)->name);
    
	静态链表练习:
	 //静态链表
    struct weapon{
        int atk;
        int price;
        struct weapon *next;
    };
    
    struct weapon a,b,c,*head;
    a.atk   = 100;
    a.price = 100;
    
    b.atk   = 200;
    b.price = 200;
    
    c.atk   = 300;
    c.price = 300;
    
    head = &a;
    a.next = &b;
    b.next = &c;
    c.next = NULL;
    
    struct weapon *p = head;
    while (p != NULL) {
        printf("weapon.atk == %d\n", p->atk);
        p = p->next;
    }
 	动态链表练习:
 	//动态链表
	 	struct weapon{
	    int atk;
	    int price;
	    struct weapon *next;
	};

	struct weapon * create(){
	    struct weapon *head;
	    struct weapon *p1,*p2;
	    
	    int n = 0;
	    p1 = p2 = (struct weapon *)malloc(sizeof(struct weapon));
	    scanf("%d,%d", &p1->atk, &p1->price);
	    head = NULL;
	    while (p1->atk != 0) {
	        n++;
	        if (n == 1) {
	            head = p1;
	        }else{
	            p2->next = p1;
	        }
	        p2 = p1;
	        p1 = (struct weapon *)malloc(sizeof(struct weapon));
	        scanf("%d,%d", &p1->atk, &p1->price);
	    }
	    p2->next = NULL;
	    return head;
	}
	
**指针函数 和 函数指针 的区别**

`指针函数` 一个函数不仅可以带回一个整型数据的值，字符类型值和实型类型的值，还可以带回指针类型的数据，使其指向某个地址单元。是指带指针的函数，即本质是一个函数。函数返回类型是某一类型的指针。返回指针的函数，一般定义格式为：

	类型标识符 *函数名(参数表)
    int* f(int x，int y);
	其中x，y是形式参数，f是函数名，调用后返回一个指向整型数据的地址指针。
	f(x，y)是函数，其值是指针。
	函数返回值必须用同类型的指针变量来接受，也就是说，
	指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。
	表示：
		float* fun();
		float* p;
		p = fun(a);

注意指针函数与函数指针表示方法的不同，千万不要混淆。最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。

`函数指针` 在程序运行中，函数代码是程序的算法指令部分，它们和数组一样也占用存储空间，都有相应的地址。可以使用指针变量指向数组的首地址，也可以使用指针变量指向函数代码的首地址，指向函数代码首地址的指针变量称为函数指针。

函数指针是指向函数的指针变量。 因而“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。如前所述，C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。函数指针有两个用途：调用函数和做函数的参数。-----百度百科

    函数类型 （*指针变量名）(形参列表)；
	"函数类型"说明函数的返回类型，由于"()"的优先级高于"*",
	所以指针变量名外的括号必不可少，后面的“形参列表”表示指针变量指向的函数所带的参数列表。
	例如：
	int (*f)(int x);
	double (*ptr)(double x);
	在定义函数指针时请注意：
	函数指针和它指向的函数的参数个数和类型都应该是—致的；
	函数指针的类型和函数的返回值类型也必须是一致的。

函数名和数组名一样代表了函数代码的首地址，因此在赋值时，直接将函数指针指向函数名就行了。
例如，

    int func(int x);   /* 声明一个函数 */
    int (*f) (int x);  /* 声明一个函数指针 */
    f = func;		   /* 将func函数的首地址赋给指针f */

赋值时函数func不带括号，也不带参数，由于func代表函数的首地址，因此经过赋值以后，指针f就指向函数func(x)的代码的首地址。
函数指针是通过函数名及有关参数进行调用的。

与其他指针变量相类似，如果指针变量pi是指向某整型变量i的指针，则`*p`等于它所指的变量i；如果pf是指向某浮点型变量f的指针，则`*pf`就等价于它所指的变量f。同样地，`*f`是指向函数func(x)的指针，则`*f`就代表它所指向的函数func。所以在执行了`f=func`;之后，(*f)和func代表同一函数。

由于函数指针指向存储区中的某个函数，因此可以通过函数指针调用相应的函数。现在我们就讨论如何用函数指针调用函数，它应执行下面三步：

    首先，要说明函数指针变量。
    例如：int (*f)(int x);
    其次，要对函数指针变量赋值。
    例如： f=func;(func(x)必须先要有定义)
    最后，要用 (*指针变量)(参数表);调用函数。
    例如：(*f)(x);(x必须先赋值)

**C/C++内存分部情况**

	一个由C/C++编译的程序占用的内存分为以下几个部分

    1、栈区(stack) ----由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其
    操作方式类似于数据结构中的栈。
    2、堆区(heap)  ----一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回
    收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
    3、全局区(静态区)(static)-----全局变量和静态变量的存储是放在一块的，初始化的
    全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另
    一块区域。 - 程序结束后由系统释放。
    4、文字常量区 -----常量字符串就是放在这里的。 程序结束后由系统释放。
    5、程序代码区 -----存放函数体的二进制代码。
	
	从管理方式来讲
	-对于栈来讲，是由编译器自动管理，无需我们手工控制；
	-对于堆来说，释放工作由程序员控制，容易产生内存泄露(memory leak)
	
	从申请大小大小方面讲
	-栈空间比较小
	-堆控件比较大
	
	从数据存储方面来讲
	- 栈空间中一般存储基本类型，对象的地址
	- 堆空间一般存放对象本身，block的copy等