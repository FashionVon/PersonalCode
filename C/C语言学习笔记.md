## C语言学习笔记 ##

**计算机三大件：操作系统、编译器、数据库。**

**include**

```
在C语言中，任何库函数使用之前都必须提前include文件

#include <文件.h>          编译器去系统目录下寻找相关的头文件
#include "文件.h"           编译器去用户当前目录下寻找相关的头文件

一个语句可以写在多行，一行可以写多个语句，语句以分号结束（#define宏定义的语句不适使用分号结束）
```

**编译器编译过程**

```shell
预编译 汇编 编译 链接 生成可执行文件

编译时会对源程序进行词法检查和语法检查

编译的基本单位是文件，文件的基本组成单位是函数（想一想编写的一个.c或.cpp文件里，除了include头文件、define宏定义、声明的全局变量和函数，就是一个个函数了（main函数也是函数））

a.c是源代码文件
预编译:替换include包含的头文件、去掉代码中的注释。  gcc -E -o ae.c a.c
汇编:将C语言转换成汇编语言。gcc -S -o as.s ae.c
编译:编译成二进制的机器指令。gcc -c -o ac.o as.s   
链接:gcc不带参数就是链接过程。gcc -o a ac.o
```






一些重要的知识点

```
计算机只能识别由0和1组成的二进制指令，需要将用高级语言（如C、C++）编写的源程序（.c、.cpp）编译成二进制目标文件（.obj）。一个程序可以根据需要写在不同的文件里，编译是以文件为单位进行的，如果程序由两个文件组成，那么编译后就得到了两个目标文件。连接的作用就是将所有的目标文件和系统提供的类库相连接，组成一个可直接执行的二进制文件（.exe），这就是最后可以执行的程序。（想想为什么在程序开头#include<math.h>，就可以在程序中调用数学函数了，是因为“连接”时，将数学库函数math.h和自己编写的程序连接在一起了，共同组成一个程序。

main()函数的函数体可以为空，如：void main(){}

C程序总是在执行完main()函数的最后一条语句后结束[错]。如果程序运行崩溃，就执行不到最后，就退出了。

函数不能嵌套定义，只能嵌套调用

常量：①十进制：数学上的数字 ②八进制：以0开头，由0-7数字组成，如012表示十进制数字10 ③十六进制：以0x开头，由0-9数字和a-e(A-E)字母组成，如0x2a表示十进制数字42（注意是数字0开头，不是字母O！）

e或E之前必须要有数字，e或E之后必须要有整数数字。如1e2[对],e3[错],2.4e3[对],3e2.4[错]

转义字符可能包含两个或多个字符（如\n，\12），但它只表示一个字符（\n是一个字符，起到换行的作用，\12表示十进制ASCII码为10的那个字符）。编译系统见到字符’\n’时，会接着找它后面的字符，把反斜杠（\）和其后字符当作一个字符，在内存中只占一个字节

字符要在单引号之间（''），如果想表示一个单引号，需要这样写：\';如果想表示一个反斜杠，需要这样写：\\

标识符命名以字母或下划线_开头，由字母、下划线和数字组成。即开头第一个字符不能是数字，标识符长度不能超过255个字符

强制类型转换的格式。(数值类型)变量，如：int i=2,想把i变成float型，需要这样写：(float)i

C语言本身不提供输入输出语句，printf(),scanf()是stdio.h头文件中提供的

int整型在有的编译器里分配4个字节（如Visual C++），有的分配2个字节。如果题目告诉sizeof(int)=2，则说明分配了2个字节。VC中，int占4个字节，数值范围为(-2^31,2^31-1)；short占2个字节，数值范围为(-2^15,2^15-1)；char占1个字节，数值范围为(-2^7,2^7-1)。这涉及到原码、反码和补码的知识，一个字节是8个二进制位，一个二进制位只能表示0或者1这两个数字。

unsigned int存储的正数范围比[signed] int几乎大了一倍

把一个字符赋值给一个字符变量，并不是把该字符本身放到内存中去，而是把这个字符所对应的ASCII码的二进制形式放到内存单元中。字符变量和整型变量是可以通用的，是互相兼容的，可以相互赋值，也可以进行算术运算。在printf()中%d输出整数，%c输出字符。但是要注意字符变量和整型变量能用的字节数是不同的，相互赋值或运算可能会导致溢出或截断。

编译分为预编译和正式编译。#define定义的符号常量虽然有名字，但它是常量不是变量。如#define PI 3.14，在进行预编译时，源程序中的所有PI都被替换成了3.14，正式编译时源程序中已经没有PI这个符号了。

关于#define定义的函数代入的问题。如：#define f(a) 3*a*a    在main()中有语句：f(3+5)，它的结果是3*3+5*3+5=29，而不是3*8*8=192. 这是因为#define定义的宏函数只能进行简单的、不智能的替换，对于它来说3+5只是一个字符串，没有数学上的含义，所以它只能把函数定义中的a换成3+5，而不能自己加个括号，不能满足这一层的逻辑要求。

符号常量没有类型，在内存中不存在以它命名的存储单元。

int a=b=0[错],int a,b=a=0[对]，这个地方可能容易错。

int n;float x,y;执行语句y=n=x=3.2后，x=3.2,n=3，但y的值是3.0而不是3！这是因为在执行y=n时，系统自动进行了隐式类型转换,y=n相当于y=(float)n

要记住指针里的重要概念：
①a[i][j] = *(*(a+i)+j) 
②指针运算符（*）和取地址运算符（&）互为逆运算
要知道表示数组元素的几种形式，如果int a[10]={0},
想表示数组中第3个元素。那么 ①a[2]  ②*(a+2)  ③int *p=a; *(p+2)

static声明的变量在函数结束后值是不会消失的，下次再调用这个函数时，变量的值是累加的，可能会出现这种类型的题。

一维数组名等于数组首元素的地址，二维数组名等于数组首行的地址。如：
int a[10]={0}, 那么a就是这个数组首元素的地址。
int a[2][3]={0}，a是这个数组首行的地址，*a才是首行首元素的地址。

函数的参数是从右往左计算的。如：
int f(int a,int b) { 
	return a+b; 
} 
int x=6,y=7,z;
z=f(f(x++,y++),f(--x,y--))运算之后的结果是23。
这里有两个需要注意的地方，
①函数参数从右往左执行，也就是说先执行f(--x,y--)再执行f(x++,y++)。
②后置自增或自减运算符，要先把这个值代入到函数中之后，再递增或递减。

关于函数参数传递的问题。
值传递时，形参值改变，不会影响到实参。
引用传递时，对形参的修改会影响到实参。
即如果想在函数中修改值并能够把这种修改体现到调用函数中（如main函数），就要传递指针（地址）。
但是这里如果和指针结合，有一个很经典的问题。如：
想在函数中交换两个数，传递指针是肯定的，但是在函数中不能交换两个数的地址，而应该直接交换两个地址所对应的值，这样才能真正实现交换。
void swap(int* pa,int* pb){ int *p;p=a;a=b;b=p}[错]
void swap(int* pa,int* pb){int p;p=*a;*a=*b;*b=p;}[对]

赋值运算符的优先级很低，只高于逗号运算符如：
int a,b; b=(a=3*5,a*4),a+15，b的结果是60，而不是30。
```



**操作系统结构**

- 用户区域:普通程序运行在用户区。
- 内核区域:操作系统、设备驱动程序运行在内核区。
  - 32位的操作系统，最大内存为4G，操作系统占用1G，剩下的3G分给用户区域。
  - RISC精简指令集;CISC复杂指令集。一般来讲X86架构的CPU都是复杂指令集，AMD Intel就是X86构架。
  - CPU:控制器 运算器 寄存器
  - CPU寄存器决定CPU

**C语言数据类型**

1. 常量：在程序中不可变化的量，定义常量时赋值。

   ```
   #define MAX 10  				//定义一个宏常量MAX 值为10
   #define STRING "Hello world" 	//定义一个字符串常量
   
   宏是预处理命令的一种
   它允许用一个标识符来表示一个字符串 "#define N 100"就是宏定义，N为宏名，100是宏的内容
   宏定义的一般形式为：#define  宏名  字符串
   #号表示这是一条预处理命令，所有的预处理命令都以#开头。
   define是预处理命令。
   宏名是标识符的一种，命名规则和标识符相同。字符串可以是常数、表达式等
   注意这里所说的字符串是一般意义上的字符序列，不要和C语言中的字符串等同，它不需要双引号
   
   const int a = 10;				//定义一个const常量值为10
   const char *str = "hello world" //定义一个const常量str
   ```

2. 变量

   ```
   int i = 10;		//定义一个变量i 值为10 int是32位的二进制整数
   ```

**原码**

- 最高位为符号位，0代表正，1代表负，其余各位代表数值本身的绝对值。

  ```
  7  ： 0000 0111
  -7 ： 1000 0111
  0  ： 0000 0000
  -0 ： 1000 0000
  ```

**反码**

- 正数反码和原码相同;负数，符号位为1，其它各位与原码相反

  ```
  7 ： 0000 0111
  -7： 1111 1000
  -0： 1111 1111
  ```

**补码**

- 原码和补码不利于计算机的运算，如：原码表示的7和-7相加，还需要判断符号位。
- 正数：原码 反码 补码相同
	 负数：最高位为1，其余各位原码取反，最后对整个数加1	 

 **sizeof关键字**

- C的关键字，求指定数据类型在内存中占用空间大小。单位字节。
- sizeof 和size_t

**内存四区**

- 代码区:程序被操作系统加载到内存后，所有的可执行代码都加载到代码区，也称代码段;这块内存在运行期间不可以修改。存放函数体的二进制代码。
- 静态区、全局区 :所有全局变量、程序中 的静态变量存放在静态区。
- 栈区:栈是一种先进后出的内存结构，所有的自动变量，函数的形参都是编译器自动放在栈中，当有一个自动变量超出其作用域时，自动从栈中弹出。 由编译器自动分配释放。一般以K为单位。当栈空间满，继续往栈中压变量的结果会溢出。
- 堆区:和栈一样，也是程序在运行过程中可以随时修改的内存区域，但是没有栈一般由代码分配释放， 若不释放，程序结束时可能由OS回收 。

**编译安装**

​	编译环境包括多个工具，它们环环相扣，称作编译工具链。主要包括以下工具：
	binutils	连接器、汇编器和其他用于目标文件和档案的工具
	gcc		编译器，将源代码转换为机器代码
	glibc        C库，提供标准例程(C函数)	
	还有一些工具，能够调用工具链，实现自动化编译：
	autoconf	自动生成 Makefile 文件
	automake	自动生成 Makefile 文件
	make		按照 Makefile 文件中的规则编译程序
使用下列命令编译安装：

	./configure1 --prefix=/opt/xxx	配置软件特性，检查编译环境，生成 Makefile文件	最常用配置选项:指定软件的安装路径
	make	根据 Makefile 编译源代码
	sudo make install 	将编译完成的程序安装到系统中。通常需要 root权限
	make clean 	清除源代码目录中的编译结果

使用 make

	用 configure所产生的Makefile文件有几个预先设定的目标可供使用：
	
	目标	用途
	make all	产生预设的目标，只敲入make也可以
	make clean	清除编译结果
	make distclean	除了清除编译结果，也把configure所产生的 Makefile 清除掉
	make install	将程序安装到系统中
	make dist	将程序和相关的文档打包为一个压缩文档以供发布
	make distcheck	打包并检验 
