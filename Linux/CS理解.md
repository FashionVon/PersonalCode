**“阻塞”与"非阻塞"与"同步"与“异步"**

常见的IO模型有四种：

    （1）阻塞IO（Blocking IO）
    （2）非阻塞IO（Non-blocking IO）
    （3）IO多路复用（IO Multiplexing)	如select、poll、epoll
    （4）异步IO（Asynchronous IO）

##1.同步与异步 ##
    
    同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)

	所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。
	换句话说，就是由调用者主动等待这个调用的结果。

	异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用
	者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

    典型的异步编程模型比如Ajax
    
    举个通俗的例子：
    你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。

    而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

## 2.阻塞与非阻塞 ##

    阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

    阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

    非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

	还是上面的例子，
	你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check(轮询)一下老板有没有返回结果。
	在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

##  3.用户空间与内核空间 ##

> 现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

## 4.进程切换 ##
> 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：

    1. 保存处理机上下文，包括程序计数器和其他寄存器。
    2. 更新PCB信息。
    3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
    4. 选择另一个进程执行，并更新其PCB。
    5. 更新内存管理的数据结构。
    6. 恢复处理机上下文。
  

## 5.内存类别 ##


    堆栈区（stack）：由编译器自动分配与释放，存放函数的参数值，局部变量，临时变量等等，它们获取的方式都是由编译器自动执行的，变量生命长度：函数结束即释放内存。
    
    堆区（heap）：一般由程序员分配与释放，即程序员不释放，程序结束时可能由操作系统回收（C/C++没有此等回收机制，Java/C#有），注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
    
    全局区（静态区）（static）：全局变量和静态变量的存储是放在一块儿的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
    参
    
    文字常量区：常量字符串是放在这里的，程序结束后由系统释放。
        
    程序代码区：存放函数体的二进制代码。

**名词解释**

 文件描述符和文件指针的区别

	文件描述符:
		内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非
	负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符
	来指定待读写的文件。在linux系统中打开文件就会获得文件描述符，它是个很小的正整数。每个进
	程在PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索
	引，每个表项都有一个指向已打开文件的指针。

	文件指针：
		C语言中使用文件指针做为I/O的句柄<文件句柄fd(file descriptor)>。文件指针指向进程
	用户区中的一个被称为FILE结构的数据结构。FILE结构包括一个缓冲区和一个文件描述符。而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指针就是句柄的句柄（在Windows系统上，文件描述符被称作文件句
	柄）。