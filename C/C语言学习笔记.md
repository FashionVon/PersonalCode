## C语言学习笔记 ##

**计算机三大件：操作系统、编译器、数据库。**

**include**

在C语言中，任何库函数使用之前都必须提前include文件。

- \#include <文件.h>          编译器去系统目录下寻找相关的头文件
- \#include "文件.h"           编译器去用户当前目录下寻找相关的头文件

**编译器编译过程**

​	 `预编译 汇编 编译 链接` 生成可执行文件。

```shell
a.c是源代码文件
预编译:替换include包含的头文件、去掉代码中的注释。  gcc -E -o ae.c a.c
汇编:将C语言转换成汇编语言。gcc -S -o as.s ae.c
编译:编译成二进制的机器指令。gcc -c -o ac.o as.s   
链接:gcc不带参数就是链接过程。gcc -o a ac.o
```
**操作系统结构**

- 用户区域:普通程序运行在用户区。
- 内核区域:操作系统、设备驱动程序运行在内核区。
  - 32位的操作系统，最大内存为4G，操作系统占用1G，剩下的3G分给用户区域。
  - RISC精简指令集;CISC复杂指令集。一般来讲X86架构的CPU都是复杂指令集，AMD Intel就是X86构架。
  - CPU:控制器 运算器 寄存器
  - CPU寄存器决定CPU

**C语言数据类型**

1. 常量：在程序中不可变化的量，定义常量时赋值。

   ```
   #define MAX 10  				//定义一个宏常量MAX 值为10
   #define STRING "Hello world" 	//定义一个字符串常量
   
   宏是预处理命令的一种
   它允许用一个标识符来表示一个字符串 "#define N 100"就是宏定义，N为宏名，100是宏的内容
   宏定义的一般形式为：#define  宏名  字符串
   #号表示这是一条预处理命令，所有的预处理命令都以#开头。
   define是预处理命令。
   宏名是标识符的一种，命名规则和标识符相同。字符串可以是常数、表达式等
   注意这里所说的字符串是一般意义上的字符序列，不要和C语言中的字符串等同，它不需要双引号
   
   const int a = 10;				//定义一个const常量值为10
   const char *str = "hello world" //定义一个const常量str
   ```

2. 变量

   ```
   int i = 10;		//定义一个变量i 值为10 int是32位的二进制整数
   ```

**原码**

- 最高位为符号位，0代表正，1代表负，其余各位代表数值本身的绝对值。

  ```
  7  ： 0000 0111
  -7 ： 1000 0111
  0  ： 0000 0000
  -0 ： 1000 0000
  ```

**反码**

- 正数反码和原码相同;负数，符号位为1，其它各位与原码相反

  ```
  7 ： 0000 0111
  -7： 1111 1000
  -0： 1111 1111
  ```

**补码**

- 原码和补码不利于计算机的运算，如：原码表示的7和-7相加，还需要判断符号位。
- 正数：原码 反码 补码相同
- 负数：最高位为1，其余各位原码取反，最后对整个数加1	 

 **sizeof关键字**

- C的关键字，求指定数据类型在内存中占用空间大小。单位字节。
- sizeof 和size_t

内存四区：

- 代码区:程序被操作系统加载到内存后，所有的可执行代码都加载到代码区，也称代码段;这块内存在运行期间不可以修改。函数在代码区。
- 静态区、全局区 :所有全局变量、程序中 的静态变量存放在静态区。
- 栈区:栈是一种先进后出的内存结构，所有的自动变量，函数的形参都是编译器自动放在栈中，当有一个自动变量超出其作用域时，自动从栈中弹出。 
- 堆区:

**编译安装**

​	编译环境包括多个工具，它们环环相扣，称作编译工具链。主要包括以下工具：
	binutils	连接器、汇编器和其他用于目标文件和档案的工具
	gcc		编译器，将源代码转换为机器代码
	glibc        C库，提供标准例程(C函数)	
	还有一些工具，能够调用工具链，实现自动化编译：
	autoconf	自动生成 Makefile 文件
	automake	自动生成 Makefile 文件
	make		按照 Makefile 文件中的规则编译程序
使用下列命令编译安装：

	./configure1 --prefix=/opt/xxx	配置软件特性，检查编译环境，生成 Makefile文件	最常用配置选项:指定软件的安装路径
	make	根据 Makefile 编译源代码
	sudo make install 	将编译完成的程序安装到系统中。通常需要 root权限
	make clean 	清除源代码目录中的编译结果

使用 make

	用 configure所产生的Makefile文件有几个预先设定的目标可供使用：
	
	目标	用途
	make all	产生预设的目标，只敲入make也可以
	make clean	清除编译结果
	make distclean	除了清除编译结果，也把configure所产生的 Makefile 清除掉
	make install	将程序安装到系统中
	make dist	将程序和相关的文档打包为一个压缩文档以供发布
	make distcheck	打包并检验
**C/C++内存分部情况**

	一个由C/C++编译的程序占用的内存分为以下几个部分:
	
	1、栈区(stack) ----由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其
	操作方式类似于数据结构中的栈。
	2、堆区(heap)  ----一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回
	收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
	3、全局区(静态区)(static)-----全局变量和静态变量的存储是放在一块的，初始化的
	全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另
	一块区域。 - 程序结束后由系统释放。
	4、文字常量区 -----常量字符串就是放在这里的。 程序结束后由系统释放。
	5、程序代码区 -----存放函数体的二进制代码。
	
	从管理方式来讲
	-对于栈来讲，是由编译器自动管理，无需我们手工控制；
	-对于堆来说，释放工作由程序员控制，容易产生内存泄露(memory leak)
	
	从申请大小大小方面讲
	-栈空间比较小
	-堆控件比较大
	
	从数据存储方面来讲
	- 栈空间中一般存储基本类型，对象的地址
	- 堆空间一般存放对象本身，block的copy等