**“阻塞”与"非阻塞"与"同步"与“异步"**

​	常见的IO模型有四种：

- 阻塞IO（Blocking IO）在linux中，默认情况下所有的socket都是blocking

  ```
  当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。
  
  所以，blocking IO的特点就是在IO执行的两个阶段都被block了。
  ```

- 非阻塞IO（Non-blocking IO）linux下，可以通过设置socket使其变为non-blocking

  ```
  当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。
  
  所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。
  ```

	 IO多路复用（IO Multiplexing)	

  ```
  IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程
  ```

- 异步IO（Asynchronous IO）

**进程的阻塞**

```
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。
```

**同步与异步**

	同步(synchronous)和异步(asynchronous)其实是针对消息的发送和接受的次序而言的(在通信中就是消息的发送和接收，在IO中就是数据的读和写)
	
	同步的意思就是消息的发送和接收是有序的，即接收和发送第二个包一定在第一个包之后第三个包之前，而不是乱序。
	
	异步的意思就是消息的发送和接收是可以乱序的，第一个包没发完可以直接发第二个包。

**阻塞与非阻塞**

    至于阻塞（block）和非阻塞（non-block）其实描述的是进程或线程进行等待时的一种方式。
    阻塞的意思是等待时进程或线程需要挂起。
    
    而非阻塞则是等待时线程或进程不需要被挂起，不影响线程的执行，这时线程或进程可以继续处理其它事
    物，不因为这个等待而受到影响（当然它仍然在等待这个消息，只不过可能会在线程或进程执行周期的某一个地方去查看消息的通知，而不是立即在原地等待）。

**用户空间与内核空间**

```
现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间(虚拟存储空间)为4G(2的32次方)。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。

为了保证用户进程不能直接操作内核(kernel)，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

针对linux操作系统而言，将最高的1G字节(从虚拟地址0xC0000000到0xFFFFFFFF)，供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF)，供各个进程使用，称为用户空间。
```

**进程切换**

```
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换(process switch)/任务切换(task switch)/上下文切换(content switch)。

因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
```

从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：

    1. 保存处理机上下文，包括程序计数器和其他寄存器。
    2. 更新PCB信息。
    3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
    4. 选择另一个进程执行，并更新其PCB。
    5. 更新内存管理的数据结构。
    6. 恢复处理机上下文。

**内存类别**


    堆栈区（stack）：由编译器自动分配与释放，存放函数的参数值，局部变量，临时变量等等，它们获取的方式都是由编译器自动执行的，变量生命长度：函数结束即释放内存。
    
    堆区（heap）：一般由程序员分配与释放，即程序员不释放，程序结束时可能由操作系统回收（C/C++没有此等回收机制，Java/C#有），注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
    
    全局区（静态区）（static）：全局变量和静态变量的存储是放在一块儿的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
    参
    
    文字常量区：常量字符串是放在这里的，程序结束后由系统释放。
        
    程序代码区：存放函数体的二进制代码。

**名词解释**

	文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
	
	内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。
	
	文件指针：
		C语言中使用文件指针做为I/O的句柄<文件句柄fd(file descriptor)>。文件指针指向进程
	用户区中的一个被称为FILE结构的数据结构。FILE结构包括一个缓冲区和一个文件描述符。而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指针就是句柄的句柄（在Windows系统上，文件描述符被称作文件句
	柄）。

**CPU进程与线程的关系和区别**

        进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。
    　　线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。
    　　进程和线程的关系：
    	    (1)一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程
    	    (2)资源分配给进程，同一进程的所有线程共享该进程的所有资源
    	    (3)处理机分给线程，即真正在处理机上运行的是线程
    	    (4)线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。
    　　进程与线程的区别:
        　　(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
        　　(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
        　　(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源
        　　(4) 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些
    　　结论：
        　　(1)线程是进程的一部分
        　　(2)CPU调度的是线程
        　　(3)系统为进程分配资源，不对线程分配资源